{"version":3,"sources":["components/Container.js","components/Row.js","components/Column.js","components/Card.js","components/Jumbotron.js","components/Image.js","App.js","index.js"],"names":["Container","props","className","fluid","children","Row","helper","Column","base","md","lg","xl","columnClassName","concat","Card","dark","header","Jumbtron","style","fontSize","score","highScore","Image","id","name","image","handleClickOnImage","src","alt","onClick","App","state","choices","clicked","randomize","array","i","length","j","Math","floor","random","resetGame","randomizedChoices","setState","includes","alert","prevState","checkHighScore","handleWin","this","console","log","Jumbotron","map","key","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.b057f521.chunk.js","sourcesContent":["import React from 'react';\n\nconst Container = props => {\n  return (\n    <div className={`container${props.fluid ? '-fluid' : ''}`}>\n      {props.children}\n    </div>\n  );\n};\n\nexport default Container;\n","import React from 'react';\n\nconst Row = props => {\n  return (\n    <div className={props.helper ? `row ${props.helper}` : 'row'}>\n      {props.children}\n    </div>\n  );\n};\n\nexport default Row;\n","import React from 'react';\n\nconst Column = ({ base = 12, md, lg, xl, children }) => {\n  let columnClassName = `col-${base}`;\n\n  if (md) {\n    columnClassName = columnClassName.concat(` col-md-${md}`);\n  }\n\n  if (lg) {\n    columnClassName = columnClassName.concat(` col-lg-${lg}`);\n  }\n\n  if (xl) {\n    columnClassName = columnClassName.concat(` col-xl-${xl}`);\n  }\n\n  return <div className={columnClassName}>{children}</div>;\n};\n\nexport default Column;\n","import React from 'react';\n\nconst Card = props => {\n  return (\n    <div className={`card mt-2 ${props.dark ? 'bg-dark' : 'bg-light'}`}>\n      {props.header && (\n        <div\n          className={`card-header ${props.dark ? 'text-light' : 'text-dark'}`}>\n          {props.header}\n        </div>\n      )}\n      <div className=\"card-body\">{props.children}</div>\n    </div>\n  );\n};\n\nexport default Card;\n\n/* anything that is defined inside the Card component when it is used\n    will be placed where props.children is called\n\n    <Card>\n      <p>Hi this is inside the card body</p>\n    </Card>\n\n    by doing this we don't have to pass down props to the Image component we used in App.js\n\n    If we imported the image component in here App.js would look like this...\n\n    <Card \n      header={name} \n      id={id}\n      name={name}\n      image={image}\n      handleClickOnImage={this.handleClickOnImage} \n      dark\n    />\n\n    and this card component would look like this\n\n  <div className={`card mt-2 ${props.dark ? 'bg-dark' : 'bg-light'}`}>\n      {props.header && (\n        <div\n          className={`card-header ${props.dark ? 'text-light' : 'text-dark'}`}>\n          {props.header}\n        </div>\n      )}\n      <div className=\"card-body\">\n        <Image\n          id={props.id}\n          name={props.name}\n          image={props.image}\n          handleClickOnImage={props.handleClickOnImage}\n        />\n      </div>\n    </div>\n    \n    we would have to pass down props to the Card from App and then pass the relevant props to the Image component because it is being used inside the Card. In this case it makes the Card less reuseable.\n\n  */\n","import React from 'react';\n\nconst Jumbtron = props => {\n  return (\n    <div\n      className={`\n      jumbotron jumbotron-fluid p-2 text-center ${\n        props.dark ? 'bg-dark text-light' : 'bg-light text-dark'\n      } `}>\n      {/* TAKE STYLE OUT JUST TO MAKE A POINT */}\n      <span className=\"m-3\" style={{ fontSize: 30 }}>\n        Score: {props.score}\n      </span>\n      <span className=\"m-3\" style={{ fontSize: 30 }}>\n        High Score: {props.highScore}\n      </span>\n    </div>\n  );\n};\n\nexport default Jumbtron;\n","import React from 'react';\n\nconst Image = ({ id, name, image, handleClickOnImage }) => {\n  return (\n    <img\n      src={image}\n      alt={name}\n      className=\"img-fluid w-100 h-50\"\n      onClick={() => handleClickOnImage(id)}\n    />\n  );\n};\n\nexport default Image;\n","import React, { Component } from 'react';\nimport Container from './components/Container';\nimport Row from './components/Row';\nimport Column from './components/Column';\nimport Card from './components/Card';\nimport Jumbotron from './components/Jumbotron';\nimport Image from './components/Image';\nimport choices from './choices.json';\n\nclass App extends Component {\n  state = {\n    choices,\n    clicked: [],\n    highScore: 0\n  };\n\n  componentDidMount() {\n    this.setState({ choices: this.randomize(this.state.choices) });\n  }\n\n  /*\n\n  Here is a JavaScript implementation of the Durstenfeld shuffle, a computer-optimized version of Fisher-Yates:\n\n/*\n * Randomize array element order in-place.\n * Using Durstenfeld shuffle algorithm.\n\nfunction shuffleArray(array) {\n  for (var i = array.length - 1; i > 0; i--) {\n      var j = Math.floor(Math.random() * (i + 1));\n      var temp = array[i];\n      array[i] = array[j];\n      array[j] = temp;\n  }\n}\nThe Fisher-Yates algorithm works by picking one random element for each original array element, and then excluding it from the next draw. Just like randomly picking from a deck of cards.\n\nThis exclusion is done in a clever way (invented by Durstenfeld for use by computers) by swapping the picked element with the current element, and then picking the next random element from the remainder. For optimal efficiency, the loop runs backwards so that the random pick is simplified (it can always start at 0), and it skips the last element because there are no other choices anymore.\n\nThe running time of this algorithm is O(n). Note that the shuffle is done in-place. So if you do not want to modify the original array, make a copy of it first with .slice(0).\n\nUpdating to ES6 / ECMAScript 2015\nThe new ES6 allows us to assign two variables at once. This is especially handy when we want to swap the values of two variables, as we can do it in one line of code. Here is a shorter form of the same function, using this feature.\n\nfunction shuffleArray(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n*/\n\n  randomize = array => {\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n\n    return array;\n  };\n\n  // resetGame but not the high score\n\n  resetGame = () => {\n    const randomizedChoices = this.randomize(this.state.choices);\n\n    this.setState({\n      clicked: [],\n      choices: randomizedChoices\n    });\n  };\n\n  // handle click on image function\n\n  handleClickOnImage = id => {\n    // this is loss condition\n    if (this.state.clicked.includes(id)) {\n      alert('you lost');\n      this.resetGame();\n    } else {\n      // if they haven't clicked the image yet...\n      // we add the id to clicked array\n      // clicked: [0, 4, 2, 9]\n      // clicked: [0, 4, 2, 9, 3]\n      // first we setState of the clicked array and randomize our choices but after don't we need to check high score and win?\n      // What would happen if we did this?\n      // this.setState(prevState => ({\n      //   clicked: [...prevState.clicked, id],\n      //   choices: this.randomize(this.state.choices)\n      // }));\n      // this.checkHighScore();\n      // this.handleWin();\n      // this.setState is asynchronous and in this case checking the high score and the win rely on the state above, but it doesn't happen in that order even though we wrote it that way.\n      // this.setState takes an optional callack function and we can use that to run those checks AFTER we set the state of clicked and choices.\n      this.setState(\n        prevState => ({\n          clicked: [...prevState.clicked, id],\n          choices: this.randomize(this.state.choices)\n        }),\n        () => {\n          this.checkHighScore();\n          this.handleWin();\n        }\n      );\n    }\n  };\n\n  // check high score\n\n  checkHighScore = () => {\n    if (this.state.clicked.length > this.state.highScore) {\n      this.setState({ highScore: this.state.clicked.length });\n    }\n  };\n\n  // handle win function\n\n  handleWin = () => {\n    if (this.state.clicked.length === this.state.choices.length) {\n      alert('You won!');\n      this.resetGame();\n    }\n  };\n\n  render() {\n    // always console.log state in the render it will give you the freshest state. or use React Dev Tools.\n    console.log(this.state);\n    // don't have to write this.state over and over if we destructure here\n    const { clicked, choices, highScore } = this.state;\n    return (\n      <Container>\n        <Jumbotron score={clicked.length} highScore={highScore} dark />\n        <Row helper={`justify-content-center`}>\n          {choices.map(({ id, name, image }) => {\n            return (\n              <Column key={id} md={2}>\n                <Card header={name} dark>\n                  <Image\n                    id={id}\n                    name={name}\n                    image={image}\n                    handleClickOnImage={this.handleClickOnImage}\n                  />\n                </Card>\n              </Column>\n            );\n          })}\n        </Row>\n      </Container>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}